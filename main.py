from train_emg_data import Ui_Form
from PyQt5 import QtCore, QtWidgets
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt
import sys
import pandas as pd
import numpy as np
import train_signals_emg
import os


class EmgApplication(Ui_Form):
    def __init__(self, definitions) -> None:
        # Initiate class and Ui_Form generated by PyQt5 Designer
        super(Ui_Form, self).__init__()
        # Set the configurations of the file generated by PyQt5 Designer
        self.setupUi(definitions)

        # Create Canvas variables to plot the graphs
        self.canvas_main_classifier = None
        self.figure_3 = None
        self.horizontalLayout_15 = None
        self.data_and_classifiers = None
        self.horizontalLayout_5 = None
        self.figure = None
        self.canvas_raw_signals = None
        self.horizontalLayout_4 = None
        self.figure_1 = None
        self.canvas_process_signals = None
        self.horizontalLayout_16 = None
        self.figure_2 = None
        self.canvas_conf_matrix = None
        self.figure_4 = None
        self.horizontalLayout_17 = None
        self.canvas_roc_curve = None

        # create the set of canvas to plot the graphs
        self.set_of_canvas()

        # Start the program without training the classifiers
        self.trained_sys = False

        # Select pages
        self.home_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.home_pg))
        self.def_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.def_pg))
        self.results_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.results_pg))
        self.contact_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.contact_pg))

        # Select the result page option
        self.plot_conf_matrix_btn.clicked.connect(lambda: self.results_pgs.setCurrentWidget(self.confusion_pg))
        self.plot_roc_curve_btn.clicked.connect(lambda: self.results_pgs.setCurrentWidget(self.roc_pg))
        self.plot_process_signals_btn.clicked.connect(
            lambda: self.results_pgs.setCurrentWidget(self.plot_processed_signals_pg))
        self.plot_raw_signals_btn.clicked.connect(
            lambda: self.results_pgs.setCurrentWidget(self.plot_raw_signals_pg))

        # Definitions buttons
        self.search_file_btn.clicked.connect(self.find_path_file)
        self.filter_1_btn.clicked.connect(self.find_path_filter_1)
        self.filter_2_btn.clicked.connect(self.find_path_filter_2)
        self.redefine_param_btn.clicked.connect(self.refresh_params)

        # Plot buttons in the results page
        self.plot_conf_matrix_btn_2.clicked.connect(self.plot_confusion_matrix)
        self.plot_roc_curve_btn_2.clicked.connect(self.plot_roc_curve)
        self.btn_plot_processed_signals.clicked.connect(self.classified_signals)
        self.plot_raw_signals_btn_2.clicked.connect(self.raw_signals_plot)

        # Train the classifiers in the home page
        self.train_all_signals.clicked.connect(self.train_myo)

    def set_of_canvas(self) -> None:
        """
        Set Canvas parameters to each graph
        """
        # Main screen
        # Raw signals Canvas
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout(self.frame_15)
        self.horizontalLayout_15.setObjectName("horizontallayout_6")
        # Canvas here
        self.figure_3 = plt.figure()
        self.canvas_main_classifier = FigureCanvas(self.figure_3)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_15.addWidget(self.canvas_main_classifier)
        # end of horizontal layout

        # Raw signals Canvas
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.frame_12)
        self.horizontalLayout_5.setObjectName("horizontallayout_5")
        # Canvas here
        self.figure = plt.figure()
        self.canvas_raw_signals = FigureCanvas(self.figure)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_5.addWidget(self.canvas_raw_signals)
        # end of horizontal layout

        # Processed signals Canvas
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.frame_13)
        self.horizontalLayout_4.setObjectName("horizontallayout_4")
        # Canvas here
        self.figure_1 = plt.figure()
        self.canvas_process_signals = FigureCanvas(self.figure_1)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_4.addWidget(self.canvas_process_signals)
        # end of horizontal layout

        # Confusion Matrix
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout(self.frame_16)
        self.horizontalLayout_16.setObjectName("horizontallayout_16")
        # Canvas here
        self.figure_2 = plt.figure()
        self.canvas_conf_matrix = FigureCanvas(self.figure_2)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_16.addWidget(self.canvas_conf_matrix)
        # end of horizontal layout

        # Roc Curve
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout(self.frame_11)
        self.horizontalLayout_17.setObjectName("horizontallayout_17")
        # Canvas here
        self.figure_4 = plt.figure()
        self.canvas_roc_curve = FigureCanvas(self.figure_4)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_17.addWidget(self.canvas_roc_curve)
        # end of horizontal layout

    def train_data(self, store=False, **kwargs) -> None:
        """
        Function used to train data
        :param store: bool -> set this to True to save .joblib files
        :param kwargs: dict -> dictionary containing the parameters for classifier
        :return: None
        """
        self.data_and_classifiers = train_signals_emg.train_signals_emg(store, **kwargs)

    def train_myo(self) -> None:
        """
        Function responsible to train the classifiers for the first time and save the .joblib files
        :return: None
        """
        # store useful information regarding the classifiers
        # self.data_and_classifiers = train_signals_emg.train_signals_emg()
        self.train_data(store=True)
        # Indicate that the classifiers have already been trained
        self.trained_sys = True
        # Read the scores achieved in the classifiers
        df = pd.read_csv("scores_of_classifiers.csv")
        # Store the scores
        values = df["Scores"]
        # PyQt5 parameter to populate the treeWidget table
        _translate = QtCore.QCoreApplication.translate
        # update the scores in the table
        for i, j in enumerate(values):
            value = j * 100
            self.treeWidget.topLevelItem(i).setText(1, _translate("Form", f"{value:.2f}%"))
        # Plot the scores in the graph
        self.main_classifier()
        self.data_successfully_trained_msg()

    def main_classifier(self) -> None:
        """
        Plot the scores of the classifiers in the graph of the Home Window page
        :return: None
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            self.figure_3.clear()
            df = pd.read_csv("scores_of_classifiers.csv")
            classifiers = df["Classifiers"]
            values = df["Scores"] * 100

            ax3 = self.figure_3.add_subplot(111)
            ax3.bar(classifiers, values)
            ax3.set_title(f'Scores of the classifiers')
            ax3.set_xlabel(f'Classifiers')
            ax3.set_ylabel(f'Scores %')

            # refresh canvas
            self.canvas_main_classifier.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def refresh_params(self) -> None:
        """
        Update the file parameters.csv that is storing the parameters of training the classifiers
        """
        frequency = self.frequency.text()
        window_time = self.window_time.text()
        n_of_channels = self.n_of_channels.currentText()
        filter_1_path = self.filter_1_path.text()
        filter_2_path = self.filter_2_path.text()
        wav_filter = self.wav_filter.text()
        levels_of_filter = self.levels_of_wav_filter.currentText()
        layers_to_use_num = int(self.layers_to_use.currentText())
        layers_to_use = []
        for i in range(layers_to_use_num):
            layers_to_use.append(i + 1)

        type_of_matrix = self.type_of_matrix.currentText()
        test_size = self.test_size.text()
        random_state = self.random_state.text()
        cv = self.cv.text()
        raw_file_data = self.file_path_label.text()

        filter_1_df = pd.read_csv(filter_1_path, index_col="Filter")
        filter_2_df = pd.read_csv(filter_2_path, index_col="Filter")

        filter_1 = filter_1_df.loc["sos_high_pass_", "Value"]
        filter_2 = filter_2_df.loc["sos_bandstop_", "Value"]

        df = pd.read_csv("Parameters/parameters.csv", index_col="Parameter")

        df.loc["frequency_of_capture", "Value"] = frequency
        df.loc["window_time", "Value"] = window_time
        df.loc["n_of_channels_and_category", "Value"] = n_of_channels
        df.loc["sos_high_pass_", "Value"] = filter_2
        df.loc["sos_bandstop_", "Value"] = filter_1
        df.loc["layers_to_catch", "Value"] = layers_to_use
        df.loc["levels_to_use", "Value"] = levels_of_filter
        df.loc["filter_to_use", "Value"] = wav_filter
        df.loc["type_matrix", "Value"] = type_of_matrix
        df.loc["test_size", "Value"] = test_size
        df.loc["random_state", "Value"] = random_state
        df.loc["cv", "Value"] = cv
        df.loc["file", "Value"] = raw_file_data
        df.to_csv("Parameters/parameters.csv")
        self.parameters_updated_msg()

    def find_path_filter_1(self) -> None:
        """
        Show the user a dialog box to choose the highpass filter file
        """
        # self.file_path_label.setText("This path")
        # Open a File Dialog
        if "PYCHARM_HOSTED" in os.environ:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)",
                options=QtWidgets.QFileDialog.DontUseNativeDialog
            )
        else:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)"
            )
        if ret:
            self.filter_1_path.setText(ret)

    def find_path_filter_2(self) -> None:
        """
        Show the user a dialog box to choose the bandstop filter file
        """
        # self.file_path_label.setText("This path")
        # Open a File Dialog
        if "PYCHARM_HOSTED" in os.environ:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)",
                options=QtWidgets.QFileDialog.DontUseNativeDialog
            )
        else:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)"
            )
        if ret:
            self.filter_2_path.setText(ret)

    def find_path_file(self) -> None:
        """
        Show the user a dialog box to choose the raw data EMG to train the classifiers
        """
        # self.file_path_label.setText("This path")
        # Open a File Dialog
        if "PYCHARM_HOSTED" in os.environ:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Raw_EMG_Data/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)",
                options=QtWidgets.QFileDialog.DontUseNativeDialog
            )
        else:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Raw_EMG_Data/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)"
            )
        if ret:
            self.file_path_label.setText(ret)

    def plot_confusion_matrix(self) -> None:
        """
        Plots Confusion Matrix based in the defined classifier
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            self.train_data()

            self.figure_2.clear()
            classifiers = {'knn': self.data_and_classifiers.knn,
                           'lda': self.data_and_classifiers.lda,
                           'gnb': self.data_and_classifiers.gnb,
                           'tree': self.data_and_classifiers.tree,
                           'lin_svm': self.data_and_classifiers.lin_svm}

            conf_classifier = self.confusion_matrix_classifier_cb.currentText()
            conf_type = self.confusin_matrix_type_cb.currentText()
            if conf_type == 'None':
                conf_type = None
            # https://stackoverflow.com/questions/19233771/sklearn-plot-confusion-matrix-with-labels
            ax4 = self.figure_2.add_subplot(111)
            ConfusionMatrixDisplay.from_estimator(classifiers[conf_classifier],
                                                  self.data_and_classifiers.m_class_test_independentVars,
                                                  self.data_and_classifiers.m_class_test_target_vars,
                                                  ax=ax4,
                                                  normalize=conf_type)

            ax4.set(xlabel='Predicted', ylabel='True', title='Confusion Matrix True vs Predicted')

            # refresh canvas
            self.canvas_conf_matrix.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def data_classifiers_to_use(self):
        classifiers = {'knn': self.data_and_classifiers.knn,
                       'lda': self.data_and_classifiers.lda,
                       'gnb': self.data_and_classifiers.gnb,
                       'tree': self.data_and_classifiers.tree,
                       'lin_svm': self.data_and_classifiers.lin_svm}
        return classifiers

    def choose_classifier(self, classifier, number=None) -> None:
        if classifier == "lda":
            use_ = {"lda": number / 10}
            self.train_data(**use_)
        elif classifier == "knn":
            use_ = {"knn": number}
            self.train_data(**use_)
        elif classifier == "tree":
            use_ = {"tree": number}
            self.train_data(**use_)
        else:
            self.train_data()

    def plot_roc_curve(self) -> None:
        """
        Plot ROC curve if the data has already been trained and it's a data with just two categories
        """
        # Check if the classifiers have already been trained

        if self.data_and_classifiers is not None:
            # Check if it just has 2 classes
            if len(np.unique(self.data_and_classifiers.m_class_test_target_vars)) <= 2:
                self.figure_4.clear()
                # Define the subplot figure
                ax5 = self.figure_4.add_subplot(111)
                # Store the classifiers in a dictionary

                use_ = {"lda": 0.5}
                self.train_data(**use_)
                # classifiers = {'knn': self.data_and_classifiers.knn,
                #               'lda': self.data_and_classifiers.lda,
                #               'gnb': self.data_and_classifiers.gnb,
                #               'tree': self.data_and_classifiers.tree,
                #               'lin_svm': self.data_and_classifiers.lin_svm}
                # Select the classifier in the Combobox
                roc_classifier = self.roc_curve_classification_cb.currentText()
                score_ = []
                if roc_classifier == "lda" or roc_classifier == "knn" or roc_classifier == "tree":
                    for i in range(1, 11):
                        self.choose_classifier(roc_classifier, i)
                        classifiers = self.data_classifiers_to_use()
                        # Predict the data from the test data
                        prediction = classifiers[roc_classifier].predict(
                            self.data_and_classifiers.m_class_test_independentVars)
                        # Stores the parameters for the ROC curve
                        fpr, tpr, thresholds = roc_curve(self.data_and_classifiers.m_class_test_target_vars, prediction)
                        # Store the ROC score
                        score_roc = roc_auc_score(self.data_and_classifiers.m_class_test_target_vars, prediction)
                        score_.append(score_roc)
                        # Plot definitions
                        if roc_classifier == "lda":
                            ax5.plot(fpr, tpr, linewidth=2, label=f"shrinkage: {i / 10}, score: {score_roc:.2f}")
                        elif roc_classifier == "knn":
                            ax5.plot(fpr, tpr, linewidth=2, label=f"Neighbours: {i}, score: {score_roc:.2f}")
                        elif roc_classifier == "tree":
                            ax5.plot(fpr, tpr, linewidth=2, label=f"Max_depth: {i}, score: {score_roc:.2f}")
                else:
                    self.choose_classifier(roc_classifier)
                    classifiers = self.data_classifiers_to_use()
                    # Predict the data from the test data
                    prediction = classifiers[roc_classifier].predict(
                        self.data_and_classifiers.m_class_test_independentVars)
                    # Stores the parameters for the ROC curve
                    fpr, tpr, thresholds = roc_curve(self.data_and_classifiers.m_class_test_target_vars, prediction)
                    # Store the ROC score
                    score_roc = roc_auc_score(self.data_and_classifiers.m_class_test_target_vars, prediction)
                    score_.append(score_roc)
                    ax5.plot(fpr, tpr, linewidth=2, label=f"Score: {score_roc:.2f}")
                ax5.plot([0, 1], [0, 1], 'k--', label="Random")
                ax5.legend(loc="lower right")
                ax5.set_xlabel("False Positive Rate")
                ax5.set_ylabel("True Positive Rate (Recall)")
                # Set the ROC score in the screen text
                max_score = max(score_)
                self.roc_auc_score_text.setText(str(max_score))
                # Draw the ROC graph
                self.canvas_roc_curve.draw()
            # Show a message box indicating that data must have just 2 classes
            else:
                msg = QtWidgets.QMessageBox()
                msg.setIcon(QtWidgets.QMessageBox.Warning)

                # setting message for Message Box
                msg.setText("Warning - Raw data has more than 2 classes")

                # setting Message box window title
                msg.setWindowTitle("Trying to plot a Roc Curve in a not binary data")

                # declaring buttons on Message Box
                msg.setStandardButtons(QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel)

                # start the app
                msg.exec_()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def raw_signals_plot(self) -> None:
        """
        Plot the Raw data signal channel selected
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            # clear the canvas
            self.figure.clear()
            # Select the channel to plot the graph
            channel_1 = int(self.cb_raw_signal_1.currentText())
            # Read the Raw Data EMG
            df = pd.read_csv(self.file_path_label.text())
            # Plot raw data values
            self.plot_values_of_channels_raw_emg(df, channel_1)
            # refresh canvas
            self.canvas_raw_signals.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def plot_values_of_channels_raw_emg(self, df, col1) -> None:
        """
        Plot Raw data for each channel
        :param df: dataframe used to store raw data EMG
        :param col1: column to plot representing the EMG channel
        :return: None
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            ax2 = self.figure.add_subplot(111)
            x = np.arange(len(df))
            y = df[df.columns[col1 + 1]]
            ax2.plot(x, y)

            # Decorate
            ax2.set_title(f'Values in Channel_{col1} and the number of the sample')
            ax2.set_xlabel(f'Number of the sample - value')
            ax2.set_ylabel(f'Chanel_{col1} - value(mv)')
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def classified_signals(self) -> None:
        """
        Plot the processed data based on the channels selected
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            # clear the canvas
            self.figure_1.clear()
            # Select the first channel (X axis)
            channel_1 = int(self.cb_plot_channel_1_process_signals.currentText())
            # Select the second channel (Y axis)
            channel_2 = int(self.cb_plot_channel_2_process_signals.currentText())
            # Read the processed data
            df = pd.read_csv("M_Class_Data/training_matrix_csv_m_class.csv")
            self.plot_values_of_channels_process_emg(df, channel_1, channel_2)
            # refresh canvas
            self.canvas_process_signals.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def plot_values_of_channels_process_emg(self, df, col1, col2) -> None:
        """
        Plot the processed data parameters
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            # Define the subplot figure
            ax1 = self.figure_1.add_subplot(111)
            # Define parameters and values of the categories
            categories = df["Category"].unique()
            colors = ["red", "blue", "green", "yellow", "brown", "azure", "chocolate", "ivory", "lavender", "olive"]
            category = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
            for i, j in enumerate(categories):
                mask = df["Category"] == j
                df_x = df[mask]
                ax1.scatter(x=df_x[df.columns[col1 - 1]], y=df_x[df.columns[col2 - 1]], color=colors[i],
                            label=f"Category: {category[i]}")

            # Decorate
            ax1.set_title(f'Values in Channel_{col1} and Chanel_{col2} per category')
            ax1.set_xlabel(f'Chanel_{col1} - value')
            ax1.set_ylabel(f'Chanel_{col2} - value')
            ax1.legend(loc='best')
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    @staticmethod
    def parameters_updated_msg() -> None:
        """
        Show a Message box, indicating that the Parameters were updated
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Information)

        # setting message for Message Box
        msg.setText("The parameters were successfully updated ")

        # setting Message box window title
        msg.setWindowTitle("Parameters Updated")

        # declaring buttons on Message Box
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)

        # start the app
        msg.exec_()

    @staticmethod
    def data_successfully_trained_msg() -> None:
        """
        Show a Message box, indicating that data was successfully trained
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Information)

        # setting message for Message Box
        msg.setText("The data was successfully trained")

        # setting Message box window title
        msg.setWindowTitle("Data Trained")

        # declaring buttons on Message Box
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)

        # start the app
        msg.exec_()

    @staticmethod
    def not_trained_model() -> None:
        """
        Show a Message box, indicating that the classifiers have not trained
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Warning)

        # setting message for Message Box
        msg.setText("Warning - Model was not trained, Train the model in the home menu")

        # setting Message box window title
        msg.setWindowTitle("Model not Trained")

        # declaring buttons on Message Box
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel)

        # start the app
        msg.exec_()


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QWidget()
    ui = EmgApplication(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
